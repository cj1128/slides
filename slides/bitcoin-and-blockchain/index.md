class: cover

# Bitcoin and Blockchain

---
class: center

## 基础知识

---

### 哈希算法

也叫摘要算法，计算**任意长度**输入的摘要，产生一个**固定长度**的输出，这个输出叫做*哈希值*。

常见的哈希算法有`MD5`，`SHA256`, `SHA512`等。

特点：
- 无冲突：无法找到两个不一样的输入，产生同样的哈希值，注意，是无法找到
- 不可逆：无法由输出推导输入

---

### 数字签名

数字签名和我们传统的签名一样，需要满足两个性质：

- 只有特定的人可以签，但是所有人都可以验证
- 签名和特定的内容绑定在一起，剪切复制是没用的

目前使用的数字签名一般由*非对称秘钥*实现，有两把钥匙，一把秘钥(SK)，一把公钥(PK)，公钥公之于众。

- 消息发布者可以使用`秘钥 + 消息`产生签名
- 其他人可以使用`公钥 + 消息 + 签名`来验证有效性

---
class: center

## 身份认证

---

### ECDSA认证系统

- *SK(Secret Key)*: 秘钥 

  ```text
  f46b86f8d9b7d7008b6a7f940ba782663e2f06eccea272a375ee49d74ec1e9f8
  ```

- *WA(Wallet Address)*: 钱包地址，交易使用这个地址
  
  ```text
  02ab20170e07d7f701ce7c4e5fa30bac0841c0aab6a448c
  7ee848af3b1a7e1cb7f18SGifBJgDWnARXaHUmM8E3FJAHnLcxZhW
  ```

- *SK -> WA*: 使用SK可以生成WA，这个过程不可逆
- *SK*和*WA*构成了非对称秘钥系统，即SK签名，WA可以验证
- 持有比特币的唯一方式为：**持有比特币WA对应的SK**

---

.Q[SK是怎样生成的呢？有什么条件吗?]

---

.A[没有任何条件，使用计算机随机生成就行。]

---
class: center

## P2P网络

---

### 点对点，去中心

- **任何计算机**都可以下载运行比特币程序，从而成为比特币网络中的一个节点。

- 去中心意味着整个系统中没有中心节点，**所有节点都是平等的**。

- 每个节点拥有比特币的完整数据，因此，**破坏比特币的唯一方式是摧毁所有的节点**。

---

.Q[为什么大家会愿意成为比特币的节点？]

---

.A[因为成为节点参与挖矿，可以获得比特币的奖励。]

---
class: center

## 交易

---

### 交易流程

- 钱包（一个软件）构造一条交易
- 向节点发送交易
- 节点验证交易有效性
- 向其他节点广播该交易
- 交易被存储进区块中

---

### 交易结构

交易由两部分构成，输入相当于汇款方，输出相当于收款方。

- `Inputs`: 输入，可能有多个
- `Outputs`: 输出，可能有多个

---

### 输入输出

每一个输入由两部分构成：

- `UTXO(Unspent Transaction Output)`: 某一个交易的输出
- `解锁脚本`: 用来解锁上述的UTXO

每一个输出也由两部分构成：

- `锁定脚本`: 指定了消费这段输出的条件
- `金额`

---

### 锁定脚本和解锁脚本

锁定脚本和解锁脚本是一套小型的编程语言，可以用来指定非常复杂的消费校验。

绝大部分交易，提供签名即可解锁UTXO。

锁定脚本中的内容：WA

解锁脚本：签名（消息为交易哈希值）

---

### 交易图解

![](slides/bitcoin-and-blockchain/transaction.svg)

---

.Q[输入金额一定等于输出金额吗？]

---

.A[不等于，准确来说，是一定不等于，之间的差额就是手续费。]

---

.Q[交易有效性需要检查哪些点？]

---

.A[UTXO没有被消费，解锁脚本和锁定脚本匹配，输入金额需要大于输出金额。]

---

.Q[如何知道一个WA的余额是多少？]

---

.A[比特币没有直接的账户余额，一个WA对应的余额需要使用目前所有的交易推导出来。]

交易之间形成一个链条，每一笔交易都能追根溯源。如果你要转钱给别人，一定是有人先转钱给你。

---

.Q[最初的钱怎么来的？]

---

.A[这就是著名的“挖矿”。]

---
class: center

## 产生

---

### 挖矿

*挖矿*：节点将交易打包在一起，形成区块的过程。

---

### 区块

一个区块由以下部分构成：

- 多个交易记录
- 父区块的哈希值
- 困难度(一个数字)
- 时间戳
- 随机数

由于每个区块都含有上个区块的哈希值，因此，区块之间形成一个链条，也就是所谓的*区块链*。

---

.Q[第一个区块的父区块是什么呢？]

---

.A[这个区块叫做创世区块，它的内容硬编码在软件当中。]

---

.Q[困难度是个什么东西？用来做什么？]

---

.A[这就涉及到比特币达成共识的核心设计，工作量证明。]

---

### POW, Proof of Work

每个节点都可以形成区块，但是形成区块必须满足特定的条件：**区块的哈希值（当做整数来解读）必须小于困难度。**

由于哈希算法的特性，**找到吻合条件哈希值的唯一做法是尝试**。尝试的过程就是不停地修改随机数，计算哈希值，检验哈希值是否吻合条件。

一旦某个节点找到了特定的随机数使得哈希值满足条件，也就是所谓的“挖到了矿”，那么这个区块就会被加入到链中，同时广播给网络中其他节点，其他节点收到消息后，校验区块的有效性，然后立刻开始“挖下一个矿”。

---

.Q[困难度是一个固定的数字吗？]

---

.A[当然不是。]

---

.Q[为什么困难度不能是一个固定的数字呢？]

---

.A[因为计算能力在增加，如果困难度是一个固定的数字，比特币就会越挖越快，导致价值下跌以及系统不稳定。]

---

.Q[作为一个分布式系统，困难度如何自动调整？]

---

.A[算法很简单，每2016个区块以后，节点会根据生成2016个区块的实际时间以及理论时间（每10分钟一个区块），调整困难度，因此，无论网络节点多少，无论计算能力大小，比特币始终保持在10分钟一个区块。]

---

.Q[比特币的交易速度怎样计算？]

---

.A[区块中包含的交易数量 / 10分钟]

区块中的交易数量平均值在2000左右，因此比特币的交易速率平均为**200笔/分钟**，作为一个全球货币，这个交易速度非常低，是比特币的一个重大缺陷。

---

###生成交易

每个区块的第一个交易是**生成交易(Generation Transaction)**。这个交易没有输入，只有输出。

生成交易将*系统奖励 + 手续费*输出到挖矿人员设定的钱包地址，这就是比特币产生的根源。

---

.Q[挖矿需要消耗什么资源？]

---

.A[一次性投资的硬件 + 维持硬件运作的电力]


---

.Q[同时有多台节点挖到矿怎么处理？]

---

.A[这就是所谓的“分叉”，节点会维护分叉的链，直到下一个区块到来。]

---

![](slides/bitcoin-and-blockchain/fork.svg)

---

.Q[分叉会造成怎样的影响？]

---

.A[分叉会修改区块链，导致交易无效，比如著名的51%攻击。]

---
### 51% Attack

.two-columns[

![](slides/bitcoin-and-blockchain/attack.svg)

<div style="width: 450px">

<p>考虑这样一个情景：A与B之间有一笔大额交易，使用比特币支付。</p>

<p>交易为T1， B在等到交易进入区块B2以后，就交付货品给A。</p>

<p>此时，A立刻调用大量计算能力，在B1的基础上重新挖矿得到B3，B3中有一笔交易T2，使用和T1同样的UTXO，但是输出为A自己的账户。</p>

<p>紧接着在B3的基础上挖出B4（A掌握了51%的计算能力），那么B2就会彻底作废。A同时拿到了钱和货。</p>

</div>
]

---

.Q[T1为何无效了？]

---

.A[节点收到T1后，会发现它的UTXO已经被支付，因此T1无效。]

---

.Q[如何防范此类攻击？]

---

.A[非常简单，等到确认度增加以后再进行交付。]

一般10以上就十分安全了，要推翻10个区块需要巨大的计算量，目前没有个体和团体能做到，这个方法的缺点是需要等待。

---

### 总结

到了这里，我想大家应该对比特币的整个系统运作有了一定的理解。

- 比特币怎么产生？
- 怎样交易？
- 怎样持有？
- 有什么优点？
- 有什么缺点？
- 它底层的区块链技术有什么特点？

.tip[注意，这篇PPT意在说明比特币的工作原理，希望能帮助大家站在一个整体的角度上去理解比特币，重在概念性解释，因此部分技术细节做了调整方便大家理解，不一定准确。]

---
class: cover

# Thank You😎
